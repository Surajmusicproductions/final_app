<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Audio Sampler Synth</title>
<!-- Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  body {
    font-family: 'Inter', sans-serif;
    background-color: #121212;
    color: #e0e0e0;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }
  .container {
    max-width: 800px;
    margin: auto;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #10B981; /* Tailwind 'emerald-500' */
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    margin-top: -8px; /* Adjust vertical position */
  }
  input[type=range]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #10B981;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }
  .key {
    transition: all 0.05s ease-in-out;
  }
  .key.active {
    transform: scale(0.95);
    background-color: #3b82f6 !important; /* Tailwind 'blue-500' */
    box-shadow: 0 0 10px #3b82f6;
  }
  .note-marker {
    position: absolute;
    width: 4px;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.6);
    cursor: ew-resize;
    border-radius: 2px;
    z-index: 10;
  }
  /* New Piano Styles for two octaves */
  .piano-container {
    position: relative;
    width: 100%;
    height: 160px;
  }
  .white-key, .black-key {
    position: absolute;
    cursor: pointer;
    border-radius: 0 0 5px 5px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    transition: background-color 0.1s ease, transform 0.1s ease, box-shadow 0.1s ease;
  }
  .white-key {
    width: 6.666%; /* 15 white keys in C4-C6 octave range */
    height: 100%;
    background-color: #f0f0f0;
    border: 1px solid #d0d0d0;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding-bottom: 8px;
  }
  .black-key {
    width: 4%;
    height: 60%;
    background-color: #121212;
    z-index: 10;
    border: 1px solid #333;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding-bottom: 8px;
  }
  .white-key.active {
      background-color: #e0e0e0;
      transform: translateY(2px);
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  }
  .black-key.active {
      background-color: #3b82f6;
      transform: translateY(2px);
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  }
</style>
</head>
<body class="p-4 sm:p-8">
  <div class="container bg-gray-800 p-6 rounded-2xl shadow-lg border border-gray-700">
    <h1 class="text-3xl font-bold text-center text-emerald-400 mb-2">Sample Synth</h1>
    <p class="text-gray-400 text-center mb-6">Create a playable synth from any audio sample. Drag on the waveform to select a segment.</p>
    
    <!-- File Input & Audio Preview -->
    <div class="mb-6">
      <label for="audioFile" class="block text-sm font-medium text-gray-400 mb-2">Upload Audio Sample (MP3, WAV)</label>
      <input type="file" id="audioFile" accept="audio/*" class="w-full text-sm text-gray-500
        file:mr-4 file:py-2 file:px-4
        file:rounded-full file:border-0
        file:text-sm file:font-semibold
        file:bg-violet-50 file:text-violet-700
        hover:file:bg-violet-100
        cursor-pointer">
    </div>

    <!-- Waveform Canvas -->
    <div class="relative w-full mb-6">
      <canvas id="waveformCanvas" class="w-full h-40 bg-gray-900 rounded-lg shadow-inner border border-gray-700 cursor-crosshair"></canvas>
      <div id="startMarker" class="note-marker left-0" draggable="true"></div>
      <div id="endMarker" class="note-marker right-0" draggable="true"></div>
    </div>

    <!-- ADSR Controls -->
    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
      <div class="flex flex-col items-center">
        <label for="attackSlider" class="text-sm text-gray-400 mb-2">Attack</label>
        <input type="range" id="attackSlider" min="0.01" max="1" value="0.05" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        <span id="attackValue" class="text-xs text-gray-500 mt-1">0.05s</span>
      </div>
      <div class="flex flex-col items-center">
        <label for="decaySlider" class="text-sm text-gray-400 mb-2">Decay</label>
        <input type="range" id="decaySlider" min="0.01" max="1" value="0.1" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        <span id="decayValue" class="text-xs text-gray-500 mt-1">0.10s</span>
      </div>
      <div class="flex flex-col items-center">
        <label for="sustainSlider" class="text-sm text-gray-400 mb-2">Sustain</label>
        <input type="range" id="sustainSlider" min="0.01" max="1" value="0.7" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        <span id="sustainValue" class="text-xs text-gray-500 mt-1">0.70</span>
      </div>
      <div class="flex flex-col items-center">
        <label for="releaseSlider" class="text-sm text-gray-400 mb-2">Release</label>
        <input type="range" id="releaseSlider" min="0.01" max="1" value="0.5" step="0.01" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
        <span id="releaseValue" class="text-xs text-gray-500 mt-1">0.50s</span>
      </div>
    </div>
    
    <!-- Virtual Piano Keyboard -->
    <div id="piano" class="relative flex justify-center select-none bg-gray-900 rounded-xl p-4 shadow-xl border border-gray-700">
      <div class="piano-container" id="piano-container">
        <!-- Keys will be dynamically generated here -->
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let audioCtx;
    let audioBuffer = null;
    let sampleStart = 0;
    let sampleEnd = 1;
    let activeNotes = new Map();
    let isDraggingCanvas = false;
    let dragStartPos = 0;
    
    // A map to track touch points and their corresponding notes
    const touchMap = new Map();

    // DOM Element references
    const audioFile = document.getElementById('audioFile');
    const waveformCanvas = document.getElementById('waveformCanvas');
    const ctx = waveformCanvas.getContext('2d');
    const piano = document.getElementById('piano');
    const pianoContainer = document.getElementById('piano-container');
    const startMarker = document.getElementById('startMarker');
    const endMarker = document.getElementById('endMarker');

    // ADSR Sliders and values
    const attackSlider = document.getElementById('attackSlider');
    const decaySlider = document.getElementById('decaySlider');
    const sustainSlider = document.getElementById('sustainSlider');
    const releaseSlider = document.getElementById('releaseSlider');
    const attackValue = document.getElementById('attackValue');
    const decayValue = document.getElementById('decayValue');
    const sustainValue = document.getElementById('sustainValue');
    const releaseValue = document.getElementById('releaseValue');

    // Update ADSR value displays
    attackSlider.oninput = () => attackValue.textContent = `${parseFloat(attackSlider.value).toFixed(2)}s`;
    decaySlider.oninput = () => decayValue.textContent = `${parseFloat(decaySlider.value).toFixed(2)}s`;
    sustainSlider.oninput = () => sustainValue.textContent = `${parseFloat(sustainSlider.value).toFixed(2)}`;
    releaseSlider.oninput = () => releaseValue.textContent = `${parseFloat(releaseSlider.value).toFixed(2)}s`;

    // Note mapping for two full octaves (C4 to C6)
    const noteSemitoneOffsets = {
      'C4': -9, 'C#4': -8, 'D4': -7, 'D#4': -6, 'E4': -5, 'F4': -4, 'F#4': -3,
      'G4': -2, 'G#4': -1, 'A4': 0, 'A#4': 1, 'B4': 2,
      'C5': 3, 'C#5': 4, 'D5': 5, 'D#5': 6, 'E5': 7, 'F5': 8, 'F#5': 9,
      'G5': 10, 'G#5': 11, 'A5': 12, 'A#5': 13, 'B5': 14,
      'C6': 15
    };
    
    const noteLayout = [
      { note: 'C4', type: 'white', position: 0 },
      { note: 'C#4', type: 'black', position: 3.333 },
      { note: 'D4', type: 'white', position: 6.666 },
      { note: 'D#4', type: 'black', position: 10 },
      { note: 'E4', type: 'white', position: 13.333 },
      { note: 'F4', type: 'white', position: 20 },
      { note: 'F#4', type: 'black', position: 23.333 },
      { note: 'G4', type: 'white', position: 26.666 },
      { note: 'G#4', type: 'black', position: 30 },
      { note: 'A4', type: 'white', position: 33.333 },
      { note: 'A#4', type: 'black', position: 36.666 },
      { note: 'B4', type: 'white', position: 40 },
      { note: 'C5', type: 'white', position: 46.666 },
      { note: 'C#5', type: 'black', position: 50 },
      { note: 'D5', type: 'white', position: 53.333 },
      { note: 'D#5', type: 'black', position: 56.666 },
      { note: 'E5', type: 'white', position: 60 },
      { note: 'F5', type: 'white', position: 66.666 },
      { note: 'F#5', type: 'black', position: 70 },
      { note: 'G5', type: 'white', position: 73.333 },
      { note: 'G#5', type: 'black', position: 76.666 },
      { note: 'A5', type: 'white', position: 80 },
      { note: 'A#5', type: 'black', position: 83.333 },
      { note: 'B5', type: 'white', position: 86.666 },
      { note: 'C6', type: 'white', position: 93.333 }
    ];

    // --- Message Box UI ---
    const createMessageBox = (message, type = 'info') => {
      const container = document.createElement('div');
      container.className = `fixed bottom-4 right-4 p-4 rounded-lg shadow-xl text-white z-50 transition-transform transform translate-y-full opacity-0`;

      let bgColor;
      if (type === 'error') bgColor = 'bg-red-500';
      else if (type === 'success') bgColor = 'bg-green-500';
      else bgColor = 'bg-blue-500';

      container.classList.add(bgColor);
      container.textContent = message;
      document.body.appendChild(container);

      // Animate in and out
      setTimeout(() => {
        container.classList.remove('translate-y-full', 'opacity-0');
        container.classList.add('translate-y-0', 'opacity-100');
      }, 10);

      setTimeout(() => {
        container.classList.remove('translate-y-0', 'opacity-100');
        container.classList.add('translate-y-full', 'opacity-0');
        setTimeout(() => container.remove(), 500);
      }, 3000);
    };

    // Function to initialize AudioContext on first user gesture
    let isAudioCtxInitialized = false;
    const initializeAudioContext = () => {
        if (isAudioCtxInitialized) return;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        isAudioCtxInitialized = true;
        createMessageBox('AudioContext initialized!', 'success');
    };

    // === Waveform Drawing and Selection ===
    const drawWaveform = () => {
      if (!audioBuffer) return;
      const width = waveformCanvas.width;
      const height = waveformCanvas.height;
      const data = audioBuffer.getChannelData(0);
      const step = Math.ceil(data.length / width);
      const amp = height / 2;

      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#1f2937'; // Background
      ctx.fillRect(0, 0, width, height);
      ctx.strokeStyle = '#4ade80'; // Waveform color (Tailwind green-400)
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(0, amp);
      for (let i = 0; i < width; i++) {
        let min = 1.0;
        let max = -1.0;
        for (let j = 0; j < step; j++) {
          const datum = data[Math.floor((i * step) + j)];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
        ctx.lineTo(i, (1 + min) * amp);
      }
      ctx.lineTo(width, amp);
      for (let i = width - 1; i >= 0; i--) {
        let min = 1.0;
        let max = -1.0;
        for (let j = 0; j < step; j++) {
          const datum = data[Math.floor((i * step) + j)];
          if (datum < min) min = datum;
          if (datum > max) max = datum;
        }
        ctx.lineTo(i, (1 + max) * amp);
      }
      ctx.closePath();
      ctx.stroke();
      ctx.fillStyle = '#10B981';
      ctx.fill();

      // Draw the selection overlay
      const startX = sampleStart * width;
      const endX = sampleEnd * width;
      ctx.fillStyle = 'rgba(191, 219, 254, 0.2)'; // Blue-200 with transparency
      ctx.fillRect(startX, 0, endX - startX, height);

      // Update marker positions
      startMarker.style.left = `${startX}px`;
      endMarker.style.left = `${endX}px`;
    };

    // New and improved dragging logic
    waveformCanvas.addEventListener('mousedown', (e) => {
        const rect = waveformCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const width = rect.width;

        const startX = sampleStart * width;
        const endX = sampleEnd * width;

        if (Math.abs(x - startX) < 10) {
            isDraggingCanvas = true;
            activeMarker = 'start';
        } else if (Math.abs(x - endX) < 10) {
            isDraggingCanvas = true;
            activeMarker = 'end';
        } else {
             isDraggingCanvas = true;
             activeMarker = 'new';
             sampleStart = x / width;
             sampleEnd = x / width;
        }
        e.preventDefault();
    });

    waveformCanvas.addEventListener('mousemove', (e) => {
      if (!isDraggingCanvas) return;
      const rect = waveformCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const width = rect.width;

      let newPos = x / width;
      if (newPos < 0) newPos = 0;
      if (newPos > 1) newPos = 1;

      if (activeMarker === 'start') {
          if (newPos < sampleEnd) {
              sampleStart = newPos;
          }
      } else if (activeMarker === 'end') {
          if (newPos > sampleStart) {
              sampleEnd = newPos;
          }
      } else if (activeMarker === 'new') {
          const [min, max] = [Math.min(sampleStart, newPos), Math.max(sampleStart, newPos)];
          sampleStart = min;
          sampleEnd = max;
      }
      drawWaveform();
    });

    waveformCanvas.addEventListener('mouseup', () => {
        isDraggingCanvas = false;
        activeMarker = null;
    });
    
    // Waveform touch dragging
    let touchDraggingMarker = null;
    let initialTouchX = 0;
    let initialMarkerPos = 0;
    
    waveformCanvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const rect = waveformCanvas.getBoundingClientRect();
        const x = e.touches[0].clientX - rect.left;
        const width = rect.width;
        
        const startX = sampleStart * width;
        const endX = sampleEnd * width;

        if (Math.abs(x - startX) < 20) {
            touchDraggingMarker = 'start';
            initialTouchX = x;
            initialMarkerPos = sampleStart;
        } else if (Math.abs(x - endX) < 20) {
            touchDraggingMarker = 'end';
            initialTouchX = x;
            initialMarkerPos = sampleEnd;
        } else {
            touchDraggingMarker = 'new';
            sampleStart = x / width;
            sampleEnd = x / width;
        }
        drawWaveform();
    });

    waveformCanvas.addEventListener('touchmove', (e) => {
        if (!touchDraggingMarker) return;
        const rect = waveformCanvas.getBoundingClientRect();
        const x = e.touches[0].clientX - rect.left;
        const width = rect.width;
        
        let newPos;
        if (touchDraggingMarker === 'new') {
            const [min, max] = [Math.min(sampleStart, x / width), Math.max(sampleStart, x / width)];
            sampleStart = min;
            sampleEnd = max;
        } else {
            const deltaX = x - initialTouchX;
            newPos = initialMarkerPos + (deltaX / width);
            if (newPos < 0) newPos = 0;
            if (newPos > 1) newPos = 1;

            if (touchDraggingMarker === 'start' && newPos < sampleEnd) {
                sampleStart = newPos;
            } else if (touchDraggingMarker === 'end' && newPos > sampleStart) {
                sampleEnd = newPos;
            }
        }
        drawWaveform();
    });

    waveformCanvas.addEventListener('touchend', () => {
        touchDraggingMarker = null;
    });


    // Audio file upload handler
    audioFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        if (!audioCtx) initializeAudioContext();
        audioCtx.decodeAudioData(event.target.result)
          .then(buffer => {
            audioBuffer = buffer;
            sampleStart = 0;
            sampleEnd = 1;
            resizeCanvas();
            createMessageBox('Audio file loaded.', 'success');
          })
          .catch(err => {
            console.error('Error decoding audio data:', err);
            createMessageBox('Error decoding audio file.', 'error');
          });
      };
      reader.readAsArrayBuffer(file);
    });

    // === ADSR Logic ===
    const applyADSR = (gainNode, now) => {
      const attack = parseFloat(attackSlider.value);
      const decay = parseFloat(decaySlider.value);
      const sustain = parseFloat(sustainSlider.value);
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setValueAtTime(0, now);
      gainNode.gain.linearRampToValueAtTime(1, now + attack);
      gainNode.gain.linearRampToValueAtTime(sustain, now + attack + decay);
    };

    const stopNote = (gainNode, now) => {
      const release = parseFloat(releaseSlider.value);
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setValueAtTime(gainNode.gain.value, now);
      gainNode.gain.linearRampToValueAtTime(0, now + release);
    };
    
    // A map to track touch IDs and their corresponding notes
    const touchNoteMap = new Map();

    // === Piano Keyboard Logic ===
    const playNote = (note, keyElement) => {
      if (!audioBuffer) {
        createMessageBox('Please upload an audio file first.', 'error');
        return;
      }
      // Ensure AudioContext is ready for mobile devices
      initializeAudioContext();
      
      keyElement.classList.add('active');

      const source = audioCtx.createBufferSource();
      source.buffer = audioBuffer;
      const gainNode = audioCtx.createGain();

      source.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      const semitones = noteSemitoneOffsets[note];
      const playbackRate = Math.pow(2, semitones / 12);
      source.playbackRate.value = playbackRate;

      const duration = audioBuffer.duration * (sampleEnd - sampleStart);
      source.start(0, audioBuffer.duration * sampleStart, duration);
      
      // Apply ADSR envelope
      applyADSR(gainNode, audioCtx.currentTime);

      activeNotes.set(note, { source, gainNode, keyElement });
    };

    const stopNoteAndCleanup = (note) => {
      if (activeNotes.has(note)) {
        const { source, gainNode, keyElement } = activeNotes.get(note);
        stopNote(gainNode, audioCtx.currentTime);
        const releaseTime = parseFloat(releaseSlider.value);
        source.stop(audioCtx.currentTime + releaseTime);
        activeNotes.delete(note);
        keyElement.classList.remove('active');
      }
    };
    
    // Unified event listeners for mouse and touch
    const handleNoteStart = (e) => {
        const targetKey = e.target.closest('.white-key, .black-key');
        if (targetKey) {
            const note = targetKey.dataset.note;
            if (!activeNotes.has(note)) {
                playNote(note, targetKey);
            }
        }
    };

    const handleNoteEnd = (e) => {
        const targetKey = e.target.closest('.white-key, .black-key');
        if (targetKey) {
            const note = targetKey.dataset.note;
            stopNoteAndCleanup(note);
        }
    };

    // Add event listeners to the piano container for multi-touch
    pianoContainer.addEventListener('mousedown', handleNoteStart);
    pianoContainer.addEventListener('mouseup', handleNoteEnd);
    pianoContainer.addEventListener('mouseleave', () => {
        // Stop all active notes when the mouse leaves the piano area
        activeNotes.forEach((noteData, note) => {
            stopNoteAndCleanup(note);
        });
    });

    pianoContainer.addEventListener('touchstart', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.touches.length; i++) {
            const touch = e.touches[i];
            const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetKey = targetElement.closest('.white-key, .black-key');
            if (targetKey && !touchNoteMap.has(touch.identifier)) {
                const note = targetKey.dataset.note;
                touchNoteMap.set(touch.identifier, note);
                if (!activeNotes.has(note)) {
                    playNote(note, targetKey);
                }
            }
        }
    });
    
    pianoContainer.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            const note = touchNoteMap.get(touch.identifier);
            if (note) {
                stopNoteAndCleanup(note);
                touchNoteMap.delete(touch.identifier);
            }
        }
    });

    // --- Dynamic Piano Rendering ---
    const renderPiano = () => {
        pianoContainer.innerHTML = '';
        
        let whiteKeyCount = 0;
        let blackKeyCount = 0;
        
        // Define the white and black key positions for the entire 2-octave range
        const whiteKeyPositions = [
            0, 6.666, 13.333, 20, 26.666, 33.333, 40,
            46.666, 53.333, 60, 66.666, 73.333, 80, 86.666,
            93.333
        ];
        const blackKeyPositions = [
            3.333, 10, 23.333, 30, 36.666, 50, 56.666, 70, 76.666, 83.333
        ];
        
        const whiteNotes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        const blackNotes = ['C#', 'D#', 'F#', 'G#', 'A#'];

        for (const note in noteSemitoneOffsets) {
            const noteName = note.slice(0, -1);
            const keyElement = document.createElement('div');
            keyElement.dataset.note = note;
            
            if (blackNotes.includes(noteName)) {
                keyElement.classList.add('black-key');
                keyElement.style.left = `${blackKeyPositions[blackKeyCount]}%`;
                blackKeyCount++;
            } else {
                keyElement.classList.add('white-key');
                keyElement.style.left = `${whiteKeyPositions[whiteKeyCount]}%`;
                whiteKeyCount++;
            }
            
            keyElement.innerHTML = `<span class="note-label text-xs font-semibold text-gray-700">${note}</span>`;
            pianoContainer.appendChild(keyElement);
        }
    };
    
    // --- Window and Canvas resizing ---
    const resizeCanvas = () => {
      waveformCanvas.width = waveformCanvas.offsetWidth;
      waveformCanvas.height = waveformCanvas.offsetHeight;
      drawWaveform();
    };
    window.addEventListener('resize', resizeCanvas);
    
    // Initial setup
    document.addEventListener('DOMContentLoaded', () => {
        resizeCanvas();
        renderPiano();
    });
  </script>
</body>
</html>
