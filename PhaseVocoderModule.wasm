#include <stdlib.h>
#include <math.h>
#include <string.h>

// A simple implementation of a phase vocoder for pitch shifting.
// It uses overlapping analysis and synthesis windows to shift pitch.

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// Simple struct for a complex number
typedef struct {
    float real;
    float imag;
} Complex;

// In-place FFT
void fft(Complex* data, int size) {
    if (size <= 1) return;
    Complex even[size/2];
    Complex odd[size/2];
    for (int i = 0; i < size/2; i++) {
        even[i] = data[2 * i];
        odd[i] = data[2 * i + 1];
    }
    fft(even, size/2);
    fft(odd, size/2);

    for (int k = 0; k < size/2; k++) {
        float t = -2.0 * M_PI * k / size;
        Complex twiddle = {cos(t), sin(t)};
        Complex t_odd = {odd[k].real * twiddle.real - odd[k].imag * twiddle.imag,
                         odd[k].real * twiddle.imag + odd[k].imag * twiddle.real};
        data[k] = (Complex){even[k].real + t_odd.real, even[k].imag + t_odd.imag};
        data[k + size/2] = (Complex){even[k].real - t_odd.real, even[k].imag - t_odd.imag};
    }
}

// In-place Inverse FFT
void ifft(Complex* data, int size) {
    for (int i = 0; i < size; i++) {
        data[i].imag *= -1.0; // Conjugate
    }
    fft(data, size);
    for (int i = 0; i < size; i++) {
        data[i].real /= size;
        data[i].imag /= -size;
    }
}

// Public functions for WebAssembly
// Malloc wrapper for float arrays
float* malloc_float(int size) {
    return (float*)malloc(size * sizeof(float));
}

// Free wrapper for float arrays
void free_float(float* ptr) {
    free(ptr);
}

// The core phase vocoder processing function.
// Takes an input float buffer, processes it, and returns a new malloc'd output buffer.
// Pitch shifting is done by adjusting the hop size in the analysis vs. synthesis phase.
int process_phase_vocoder(float* in_ptr, int in_len, float pitch_factor, int fft_size, int hop) {
    if (in_ptr == NULL || in_len <= 0) {
        return 0;
    }

    // Calculate the synthesis hop size based on pitch factor
    int syn_hop = (int)(hop * pitch_factor);

    // Malloc the output buffer
    float* out_ptr = malloc_float(in_len);
    if (out_ptr == NULL) {
        return 0;
    }
    memset(out_ptr, 0, in_len * sizeof(float));

    // Phase storage for coherent synthesis
    float* phase_accumulator = (float*)malloc(sizeof(float) * fft_size / 2 + 1);
    memset(phase_accumulator, 0, sizeof(float) * fft_size / 2 + 1);
    float* last_phase = (float*)malloc(sizeof(float) * fft_size / 2 + 1);
    memset(last_phase, 0, sizeof(float) * fft_size / 2 + 1);

    // Process frame by frame
    for (int i = 0; i < in_len - fft_size; i += hop) {
        // Prepare analysis window
        Complex window_data[fft_size];
        for (int j = 0; j < fft_size; j++) {
            window_data[j].real = in_ptr[i + j] * (0.5 - 0.5 * cos(2 * M_PI * j / (fft_size - 1)));
            window_data[j].imag = 0.0;
        }

        // FFT
        fft(window_data, fft_size);

        // Synthesis phase
        Complex synthesis_data[fft_size];
        float freq_per_bin = (float)(M_PI * 2.0 * hop) / (float)fft_size;

        for (int k = 0; k < fft_size / 2 + 1; k++) {
            float magnitude = sqrt(window_data[k].real * window_data[k].real + window_data[k].imag * window_data[k].imag);
            float phase = atan2(window_data[k].imag, window_data[k].real);

            float delta_phase = phase - last_phase[k] - freq_per_bin;
            last_phase[k] = phase;

            float phase_diff = fmod(delta_phase + M_PI, 2.0 * M_PI) - M_PI;
            float true_frequency = (freq_per_bin + phase_diff) / (float)hop * fft_size / (2 * M_PI);
            float syn_frequency = true_frequency * pitch_factor;

            phase_accumulator[k] += syn_frequency * (2 * M_PI) * (float)syn_hop / fft_size * (2 * M_PI);

            synthesis_data[k].real = magnitude * cos(phase_accumulator[k]);
            synthesis_data[k].imag = magnitude * sin(phase_accumulator[k]);
        }

        for (int k = fft_size / 2 + 1; k < fft_size; k++) {
            synthesis_data[k] = synthesis_data[fft_size - k];
        }

        // IFFT
        ifft(synthesis_data, fft_size);

        // Overlap-add
        int syn_pos = (int)(i * pitch_factor);
        for (int j = 0; j < fft_size; j++) {
            if (syn_pos + j < in_len) {
                out_ptr[syn_pos + j] += synthesis_data[j].real * (0.5 - 0.5 * cos(2 * M_PI * j / (fft_size - 1)));
            }
        }
    }

    free(phase_accumulator);
    free(last_phase);

    return (int)out_ptr;
}
